name: Deploy IaC - Deploy Docker With AWS SSM
on:
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch para deploy"
        default: "master"
        required: true
        type: string
env:
  REPOSITORY_NAME: iac-devops-ai-project
  REPOSITORY_NAME_LC: iac-devops-ai-project
  APPLICATION: iac-devops-ai-project
  APPLICATION_LC: iac-devops-ai-project
  ORGANIZATION: alexandresouza-gft
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_CLOUD_REGION: us-east-1

jobs:
  Deploy-IA-Devops-Stack:
    runs-on: ubuntu-latest

    environment:
      name: puc-minas

    container:
      image: ubuntu:latest
      options: --user root

    steps:
      - name: Checkout the repo
        uses: actions/checkout@v4

      - name: Pre-Config
        run: |
          apt update
          apt install -y \
            openssh-client openssh-server \
            rsync grsync git sshpass curl jq unzip \
            gpg lsb-release ca-certificates

      - name: Install AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          ./aws/install

      - name: Install Terraform
        run: |
          wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | tee /etc/apt/sources.list.d/hashicorp.list
          apt update && apt install -y terraform

      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id "$AWS_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$AWS_SECRET_ACCESS_KEY"
          aws configure set region "$AWS_CLOUD_REGION"
          aws sts get-caller-identity

      # ====== Terraform Deploy ======
      - name: Terraform Deploy
        id: tf
        shell: bash
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_CLOUD_REGION }}
        run: |
          terraform init -input=false
          terraform plan -input=false -no-color
          terraform apply -input=false -auto-approve

          # Exporta outputs não sensíveis
          echo "EC2_IP=$(terraform output -raw ec2_public_ip)" >> $GITHUB_OUTPUT
          echo "SSH_USER=$(terraform output -raw ssh_user 2>/dev/null || echo ubuntu)" >> $GITHUB_OUTPUT
          echo "INSTANCE_ID=$(terraform output -raw instance_id | tr -d '[:space:]')" >> "$GITHUB_OUTPUT"

      # ====== Wait for EC2 ======
      - name: Wait for EC2 to be ready (AWS CLI)
        env:
          INSTANCE_ID: ${{ steps.tf.outputs.INSTANCE_ID }}
        run: |
          echo "⏳ Esperando EC2 ($INSTANCE_ID) ficar em running..."
          aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"

          echo "⏳ Esperando EC2 ($INSTANCE_ID) passar nos status checks..."
          aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID"

          echo "✅ Instância está pronta!"

      # ====== Wait for SSM Managed ======
      - name: Wait for SSM Managed (instance registered)
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.tf.outputs.INSTANCE_ID }}
        run: |
          echo "⏳ Aguardando a instância $INSTANCE_ID registrar no SSM..."
          for i in {1..60}; do
            COUNT=$(aws ssm describe-instance-information \
              --query "InstanceInformationList[?InstanceId=='${INSTANCE_ID}'] | length(@)" \
              --output text 2>/dev/null || echo 0)
            if [ "$COUNT" = "1" ]; then
              echo "✅ Instância registrada no SSM."
              break
            fi
            sleep 5
          done
          if [ "${COUNT:-0}" != "1" ]; then
            echo "❌ A instância não apareceu no SSM a tempo."
            exit 1
          fi

      # ====== Deploy via AWS SSM Run Command ======
      - name: (Re)deploy Application via SSM
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.tf.outputs.INSTANCE_ID }}
          GH_USER: ${{ secrets.GMS_GITHUB_TOKEN_USER }}
          GH_TOKEN: ${{ secrets.GMS_GITHUB_TOKEN }}
          ORG: ${{ env.ORGANIZATION }}
          REPO: ${{ env.REPOSITORY_NAME }}
          ENV_FILE: ${{ secrets.GEMINI_TOKEN }}
        run: |
          # Monta o arquivo de parâmetros para o Run Command (expande variáveis aqui)
          cat > /tmp/ssm-params.json <<EOF
          {
            "commands": [
              "if ! command -v docker >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y docker.io docker-compose-plugin && sudo systemctl enable --now docker; fi",
              "mkdir -p /opt/devops-stack && cd /opt/devops-stack",
              "rm -rf ${REPO} || true",
              "git clone https://${GH_USER}:${GH_TOKEN}@github.com/${ORG}/${REPO}.git ${REPO}",
              "cd ${REPO}",
              "printf '%s\\n' '${ENV_FILE}' > .env",
              "sudo docker compose down || true",
              "sudo docker compose up -d --build"
            ]
          }
          EOF

          # Envia comando
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy app via SSM" \
            --parameters file:///tmp/ssm-params.json \
            --query "Command.CommandId" \
            --output text)

          echo "CommandId: $CMD_ID"

          # Poll até finalizar (Success/Failed/TimedOut/Cancelled)
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || true)

            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then
              echo "✅ Deploy concluído com sucesso via SSM."
              break
            elif [[ "$STATUS" = "Failed" || "$STATUS" = "TimedOut" || "$STATUS" = "Cancelled" ]]; then
              echo "❌ Deploy falhou com status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$CMD_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardOutputContent" \
                --output text || true
              exit 1
            fi
            sleep 10
          done

          # Se não saiu do loop com sucesso
          if [ "${STATUS:-}" != "Success" ]; then
            echo "❌ Deploy não concluiu dentro do tempo esperado."
            exit 1
          fi

      # 📝 Resumo amigável no Job Summary
      - name: Publish summary
        env:
          EC2_IP: ${{ steps.tf.outputs.EC2_IP }}
          INSTANCE_ID: ${{ steps.tf.outputs.INSTANCE_ID }}
          SSH_USER: ${{ steps.tf.outputs.SSH_USER }}
        run: |
          {
            echo "## Deploy - Resumo"
            echo ""
            echo "- **EC2 IP:** \`$EC2_IP\`"
            echo "- **Instance ID:** \`$INSTANCE_ID\`"
            echo "- **SSM Document:** AWS-RunShellScript"
            echo "- **Repo:** \`${{ env.ORGANIZATION }}/${{ env.REPOSITORY_NAME }}\`"
            echo ""
            echo "> Sem SSH/porta 22: deploy realizado via AWS SSM Run Command."
          } >> "$GITHUB_STEP_SUMMARY"
